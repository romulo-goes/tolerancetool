"""
Interface to PRISM

Requires prism installation:

https://www.prismmodelchecker.org/download.php

"""

import os
import subprocess
from pathlib import Path

import igraph as ig

from DESops.automata.DFA import DFA
from DESops.automata.event import Event
from DESops.SDA import event_extensions as ee


def MDP_max_reachability(A, X_crit, prism_path, save_model=False, prop_string=None):
    """
    A: MDP arena, generated by construct_MDP
    X_crit: set of names of vertices in A, critical states in arena
    prism_path: path to locally installed prism installation

    save_model: (default False) save .prism and .props files (otherwise deleted, default)
    prop_string: (default None)

    """
    if A.vcount() == 0:
        return (dict(), None, DFA())
    file_names = convert_MDP_to_prism(
        A, X_crit, prism_path, save_model=False, prop_string=None
    )
    values = prism(file_names[0], file_names[1], prism_path)

    vertex_val = values[0]
    max_prob = values[1]

    # Optionally keep the files, otherwise delete
    if not save_model:
        os.remove(file_names[0])
        os.remove(file_names[1])
    Att = extract_adversary(A)
    return (vertex_val, max_prob, Att)


def MDP_multi_min_cost(A, X_crit, prism_path, save_model=False, prop_string=None):
    if A.vcount() == 0:
        return (None, None)
    file_names = convert_MDP_to_prism(
        A, X_crit, prism_path, save_model=False, prop_string=None
    )
    values = prism(file_names[0], file_names[1], prism_path, False)

    vertex_val = values[0]
    max_prob = values[1]

    # Optionally keep the files, otherwise delete
    min_cost = prism_multi_cost(file_names[0], prism_path, max_prob)

    if not save_model:
        os.remove(prism_file)
        os.remove(props_file)
    # Att = extract_adversary(A)
    return (max_prob, min_cost)


def convert_MDP_to_prism(A, X_crit, prism_path, save_model=False, prop_string=None):
    # Creates .prism and .props files
    #
    prism_file = create_model_file(A, X_crit, "temp.prism")
    props_file = create_props_file(A, "temp.props", prop_string)

    # values = prism(prism_file, props_file, prism_path)
    # vertex_val = values[0]
    # max_prob = values[1]
    # # Optionally keep the files, otherwise delete
    # if not save_model:
    #     os.remove(prism_file)
    #     os.remove(props_file)

    return (prism_file, props_file)


def create_prism_files(A, X_crit, model_fname, props_fname, prop_string=None):
    create_model_file(A, X_crit, model_fname)
    create_props_file(A, props_fname, prop_string)


def create_model_file(A, X_crit, model_fname):
    with open(model_fname, "w") as f:
        print("mdp", file=f)
        print("", file=f)
        print("module M", file=f)
        print("        x : [0 .. {0}] init 0;".format(A.vcount() - 1), file=f)

        for v in A.vs:
            # print({e["label"] for e in A.es(_source = v.index)})
            # action_set = {e["label"] if type(e["label"])==str else '_'.join(e["label"]) for e in A.es(_source = v.index)}
            action_set = {e["label"] for e in A.es(_source=v.index)}
            for a in action_set:
                if type(a) == str:
                    line = "        [{0}] x={1} -> ".format(str2(a), v.index)
                    cntr = 0
                else:
                    line = "        [{0}] x={1} -> ".format(str2(a), v.index)
                    cntr = 0

                for e in A.es(_source=v.index)(label_eq=a):
                    line = line + "{0} : (x'={1}) + ".format(e["prob"], e.target)
                    cntr += 1
                # Remove last ' + ', and add a ';'
                line = line[:-3] + ";"
                print(line, file=f)
                # [{action}] x={v.index} -> {p0} : (x'={e0.target}) + {p1} : (x'={e1.target} + ... ;
        print("endmodule", file=f)

        print("", file=f)

        print('rewards "cost"', file=f)
        actions_checked = set()
        for e in A.es():
            if e["label"] and e["label"] not in actions_checked:
                if type(e["label"]) == str:
                    actions_checked.add(e["label"])
                    print(
                        "       [{0}] true : {1};".format(str2(e["label"]), e["cost"]),
                        file=f,
                    )
                else:
                    actions_checked.add(e["label"])
                    print(
                        "       [{0}] true : {1};".format(str2(e["label"]), e["cost"]),
                        file=f,
                    )
        print("endrewards", file=f)

        print("", file=f)

        target_states = [v.index for v in A.vs if v["name"][0] in X_crit]
        line = 'label "reachability" = '
        for t in target_states:
            line = line + "x={0} | ".format(t)
        line = line[:-3] + ";"
        print(line, file=f)

    return model_fname


def create_props_file(A, props_fname, prop_string=None):
    # max probability for each state
    if not prop_string:
        prop_string = 'filter(print, Pmax=? [F "reachability"])'
    with open(props_fname, "w") as f:
        print(prop_string, file=f)
    return props_fname


def prism(prism_file, props_file, prism_path, adversary=True):
    # Run subprocess command:
    # prism model.prism properties.props
    # But need to include paths to each of the above. The Popen
    # command will switch to the directory of the prism.bat file,
    # and then the absolute path to each of the files must be used.

    # THIS IS ONLY FOR DEBIAN BASED SYSTEM
    # MUST MAKE FLEXIBLE FOR WINDOWS AND MACOS
    prism_file = str(Path().absolute()) + "/" + prism_file
    props_file = str(Path().absolute()) + "/" + props_file
    prop1 = "-pctl"
    # prop2 = "Pmax=? [F \"reachability\"]"
    prop2 = 'filter(print, Pmax=? [F "reachability"])'
    prop3 = "-lp"
    if adversary:
        prop4 = "-exportadv"
        prop5 = str(Path().absolute()) + "/" + "adversary.tra"
        commands = ["./prism", prism_file, prop1, prop2, prop3, prop4, prop5]

        output, _ = subprocess.Popen(
            commands, cwd=prism_path, stdout=subprocess.PIPE, encoding="utf-8"
        ).communicate()
    else:
        commands = ["./prism", prism_file, prop1, prop2, prop3]
        output, _ = subprocess.Popen(
            commands, cwd=prism_path, stdout=subprocess.PIPE, encoding="utf-8"
        ).communicate()
    # Process the output: prism output is a lot of text, with the relevant values
    # coming after "Results" keyword.
    split_on_results = output.split("Results")
    assert len(split_on_results) > 1, "Could not find results from PRISM"
    second_half = split_on_results[1]
    split_on_newline = second_half.split("\n")
    vertex_values = dict()
    for l in split_on_newline:
        if not l:
            continue

        after_parens = l.split("(")

        if len(after_parens) == 1:
            continue
        vertex = after_parens[1].split(")")[0]
        if vertex.isnumeric():
            # The value is whatever comes after the equals sign, sans the trailing apostrophe
            value = l.split("=")[1]
            vertex_values[int(vertex)] = float(value)

        elif l.find("initial state") > 0:
            max_prob = float(l[l.index(":") + 2 : l.index("(") - 1])

    return [vertex_values, max_prob]


def prism_multi_cost(prism_file, prism_path, max_prob):
    # Run subprocess command: prism MODEL -pctl multi(R{\"cost\"}min=?[ C ], P>="+str(max_prob)+" [ F \"reachability\"])
    # prism model.prism max_prob
    # But need to include paths to each of the above. The Popen
    # command will switch to the directory of the prism.bat file,
    # and then the absolute path to each of the files must be used.
    # outputs min cost based on max_prob
    # outputs adversary (strategy) that achieves min cost

    # THIS IS ONLY FOR DEBIAN BASED SYSTEM
    # MUST MAKE FLEXIBLE FOR WINDOWS AND MACOS
    prism_file = str(Path().absolute()) + "/" + prism_file
    prop1 = "-pctl"
    prop2 = 'multi(R{"cost"}min=?[ C ], P>=' + str(max_prob) + ' [ F "reachability"])'
    prop3 = "-lp"
    prop4 = "-exportadv"
    prop5 = str(Path().absolute()) + "/" + "adversary.tra"
    prop6 = "-s"
    commands = ["./prism", prism_file, prop1, prop2, prop3, prop4, prop5, prop6]

    output, _ = subprocess.Popen(
        commands, cwd=prism_path, stdout=subprocess.PIPE, encoding="utf-8"
    ).communicate()

    # Process the output: prism output is a lot of text, with the relevant values
    # coming after "Results" keyword. The values are organized as a
    split_on_results = output.split("Result")
    second_half = split_on_results[1]

    split_on_newline = second_half.split("\n")
    for l in split_on_newline:

        if not l:
            continue
        after_parens = l.split("(")
        if l.find("initial state") > 0:
            min_cost = float(l[l.index(":") + 2 : l.index("(") - 1])

    return min_cost


def extract_adversary(A):
    # open adversary.tra generated by either prism or prism_multi_cost
    # outputs an attack function enconded as an automaton
    Q = list()
    state_names = list()
    trans_list = list()
    trans_labels = list()
    init_state = (0, 0, "eps")
    with open("adversary.tra", "r") as f:
        for line in f:
            line = line[0 : len(line) - 1].split(" ")

            if len(line) > 2:
                source = line[0]
                if A.vs[int(source)]["name"] not in state_names:
                    state_names.append(A.vs[int(source)]["name"])
                target = line[1]
                if A.vs[int(target)]["name"] not in state_names:
                    state_names.append(A.vs[int(target)]["name"])
                prob = line[2]
                action = line[3]
                if action == "tau":
                    ev = A.vs[int(target)]["name"][2]
                    trans = (A.vs[int(source)]["name"], A.vs[int(target)]["name"])
                    trans_list.append(trans)
                    trans_labels.append(ev)

                elif action == "nd":
                    ev = A.vs[int(target)]["name"][2]
                    trans = (A.vs[int(source)]["name"], A.vs[int(target)]["name"])
                    trans_list.append(trans)
                    trans_labels.append(Event("nd"))

                elif action[-2:] == "_d":
                    trans = (A.vs[int(source)]["name"], A.vs[int(target)]["name"])
                    trans_list.append(trans)
                    trans_labels.append(ee.deleted_event(action[:-2]))

                elif action[-2:] == "_i":
                    trans = (A.vs[int(source)]["name"], A.vs[int(target)]["name"])
                    trans_list.append(trans)
                    trans_labels.append(ee.inserted_event(action[:-2]))

        Att = DFA()

        trans_ind = [
            (state_names.index(l[0]), state_names.index(l[1])) for l in trans_list
        ]

        Att.vs["name"] = state_names
        Att.add_vertices(len(state_names), state_names)

        Att.add_edges(trans_ind, trans_labels)
        Att.es["deletion"] = [1 if ee.is_deleted(e) else 0 for e in trans_labels]
        Att.es["notdeletion"] = [1 if e.label != "nd" else 0 for e in trans_labels]

        inf = float("inf")
        connected = Att._graph.shortest_paths(source=Att.vs[0])[0]

        Att.delete_vertices(
            [index for index, value in enumerate(connected) if value == inf]
        )

        return Att


def str2(word):
    if isinstance(word, Event):
        if ee.is_inserted(word):
            return word.label + "_i"
        elif ee.is_deleted(word):
            return word.label + "_d"
        return word.label
    return word
